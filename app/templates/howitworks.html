<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Semantic Web Layout</title>
<style>
  *{
    margin: 0;
  }
  body{
    min-height: 100vh;
    display: grid;
    grid-template-columns: 60px 200px 1fr;
    grid-template-rows: auto 1fr auto;
    grid-template-areas: 
    "section navbar navbar"
    "section aside main"
    "section aside footer";
  }
  nav{
    height: 3rem;
    top: 0;
    position: sticky;
    grid-area: navbar;
    background-color: aqua;
    color: black;
    padding: 0.3em;
  padding-left: 0.8em;
  font-family: 'Poppins', sans-serif;
  font-weight: 600;
  letter-spacing: 0.5px;
  font-size: 22px;
  z-index: 1000; 
  }
  section{
  grid-area: section;
  background-color: darkcyan;
  width: max-content;
  height: 100vh;
}
   aside{
    height: calc(100vh - 3rem);
    top: 3rem;
    position: sticky;
    align-self: start;
    grid-area: aside;
    background-color: white;
     border: 1px solid #D1D5DB;
  }
   main{
    grid-area: main;
  display: grid;
  grid-template-columns: 250px 1fr 250px;
  gap: 20px;
  padding: 20px 100px 20px 100px;
  box-sizing: border-box;
  }
  main > div {
  background: white;
  padding: 15px;
  border-radius: 8px;
  border: 1.5px solid #D1D5DB;
}
   footer{
    grid-area: footer;
  }
  #intro{
    padding: 1em 1em 1em 6em;
  }
</style>
</head>
<body>
  <nav>TootHack</nav>
  <section><div>{% include 'sidebar.html' %}</div> </section>
  <aside>
    <div id="inputbox"> <input type="file" id="fileInput"> </div>
    <div class="tabs">
            <button class="active" data-tab="overview">Overview</button>
            <button data-tab="recommendation">Recommendation</button>
        </div>
  </aside>
  <div> 
     <div id="intro">
            <h2>AI Analysis Results</h2>
            <p>Below is a summary of the detected issues from your AI analysis</p>
     </div>
    
    <main id="overview" class="active">
      <div>
      <h2>Column 1</h2>
         <div style="margin: 10px 0;">
    <label for="drawMode">Display Mode: </label>
    <select id="drawMode">
        <option value="shapes">Draw Shapes (BBox + Mask, No Labels)</option>
        <option value="labels" selected>Draw Labels (BBox + Mask + Labels)</option>
        <option value="blacken">Blacken Mask</option>
        <option value="bbox">BBox Only</option>
        <option value="mask">Mask Only</option>
    </select>

     <div id="detectionsContainer">
                <!-- Detection cards will be inserted here -->
                <div class="card">
                    <h3>Analysis Results</h3>
                    <p>Upload an X-ray to see detection results</p>
                </div>
            </div>
</div>
    </div>
    <div class="card">
      <h3>Visual Feedback</h3>
                <div id="resultContainer">
                    <img id="resultImg" style="max-width:100%; border:1px solid #ccc; display: none;">
                    <!-- Canvas will be inserted here dynamically -->
                </div>
    </div>
    <div id="detectionCounter" class="detection-counter" style="display: none;">
      <h4>Detection Summary</h4>
                    <div id="counterItems">
                        <!-- Counter items will be inserted here -->
                    </div>
    </div>
    </main>
    
  </div>
  <footer>Footer</footer>
</body>
<script>
    const tabs = document.querySelectorAll(".tabs button");
    const sections = document.querySelectorAll("main");
    let currentDetections = [];
    let currentImageData = null;
    let currentDetectionData = [];
    let originalImageData = null;
    let activeFilter = null;
    let selectedDetections = new Set();
    let originalImage = null;
    let canvas = null;
    let ctx = null;
    let detectionOverlays = [];
    let drawMode = "labels";

    //detection counter
    function updateDetectionCounter(detections) {
        const counterContainer = document.getElementById('detectionCounter');
        const counterItems = document.getElementById('counterItems');
        
        if (!detections || detections.length === 0) {
            counterContainer.style.display = 'none';
            return;
        }
        
        const classCounts = {};
        detections.forEach(detection => {
            const className = detection.class;
            classCounts[className] = (classCounts[className] || 0) + 1;
        });
        
        const sortedClasses = Object.keys(classCounts).sort((a, b) => classCounts[b] - classCounts[a]);
        
        counterItems.innerHTML = '';
        
        sortedClasses.forEach(className => {
            const count = classCounts[className];
            const counterItem = document.createElement('div');
            counterItem.className = 'counter-item';
            counterItem.innerHTML = `
                <span class="counter-class">${className}</span>
                <span class="counter-count">${count}</span>
            `;
            counterItems.appendChild(counterItem);
        });
        
        counterContainer.style.display = 'block';
    }

    tabs.forEach(tab => {
        tab.addEventListener("click", () => {
            tabs.forEach(t => t.classList.remove("active"));
            sections.forEach(s => s.classList.remove("active"));

            tab.classList.add("active");
            document.getElementById(tab.dataset.tab).classList.add("active");
        });
    });

    async function initializeCanvas() {
        if (!canvas) {
            canvas = document.createElement('canvas');
            canvas.style.display = 'block';
            canvas.style.maxWidth = '100%';
            canvas.style.height = 'auto';
            
            const resultContainer = document.getElementById('resultContainer');
            const resultImg = document.getElementById('resultImg');
            
            // Replace image with canvas
            resultImg.style.display = 'none';
            resultContainer.appendChild(canvas);
            
            ctx = canvas.getContext('2d');
        }
    }

    function drawImageWithFilter(selectedIds = null) {
        if (!originalImage || !canvas || !ctx) return;
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw original image
        ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);
        
        detectionOverlays.forEach(overlay => {
            if (!selectedIds || selectedIds.includes(overlay.id)) {
                drawDetection(overlay);
            }
        });

    }
    document.getElementById("drawMode").addEventListener("change", (e) => {
    drawMode = e.target.value;

    // Redraw immediately with current filter/selection
    if (selectedDetections.size > 0) {
        filterImage(Array.from(selectedDetections));
    } else if (activeFilter) {
        const filteredDetections = currentDetections.filter(d => d.class === activeFilter);
        filterImage(filteredDetections.map(d => d.id));
    } else {
        filterImage(null); // redraw everything
    }
});
    function drawDetection(detection) {
    const { bbox, class: className, confidence, color, mask } = detection;

    const scaleX = canvas.width / originalImage.width;
    const scaleY = canvas.height / originalImage.height;

    const [x1, y1, x2, y2] = [
        bbox[0] * scaleX,
        bbox[1] * scaleY,
        bbox[2] * scaleX,
        bbox[3] * scaleY
    ];

    let bboxColor = '#ff0000';
    let rgbColor = [255, 0, 0];
    if (Array.isArray(color)) {
        bboxColor = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
        rgbColor = color;
    }

    // Handle mask drawing first
    if (mask && (drawMode !== "bbox")) {   // skip mask if mode is BBox only
        const maskImg = new Image();
        maskImg.onload = function() {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = maskImg.width;
            tempCanvas.height = maskImg.height;
            tempCtx.drawImage(maskImg, 0, 0);

            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                if (data[i + 3] > 0) {
                    if (drawMode === "blacken") {
                        data[i]   = 0;   // R
                        data[i+1] = 0;   // G
                        data[i+2] = 0;   // B
                        data[i+3] = 255; // Alpha (0 = transparent, 255 = fully opaque)
                    } else {
                        data[i] = rgbColor[0];
                        data[i+1] = rgbColor[1];
                        data[i+2] = rgbColor[2];
                    }
                }
            }

            tempCtx.putImageData(imageData, 0, 0);

            // For blacken, draw solid (no opacity)
            if (drawMode === "blacken") {
                ctx.globalAlpha = 1.0;
            } else {
                ctx.globalAlpha = 0.9; // semi-transparent for colored masks
            }

            ctx.drawImage(
                tempCanvas,
                bbox[0], bbox[1], bbox[2] - bbox[0], bbox[3] - bbox[1],
                x1, y1, x2 - x1, y2 - y1
            );

            ctx.globalAlpha = 1.0;

            // Draw BBox if NOT in mask-only mode
            if (drawMode !== "blacken" && drawMode !== "mask") {
                ctx.strokeStyle = bboxColor;
                ctx.lineWidth = 2;
                ctx.strokeRect(x1, y1, x2-x1, y2-y1);
            }

            // Draw label only if mode = labels
            if (drawMode === "labels") {
                ctx.fillStyle = bboxColor.replace(')', ', 0.7)').replace('rgb', 'rgba');
                ctx.fillRect(x1, y1 - 20, 150, 20);

                ctx.fillStyle = 'white';
                ctx.font = '14px Arial';
                ctx.fillText(`${className}: ${(confidence * 100).toFixed(1)}%`, x1+5, y1-5);
            }
        };
        maskImg.src = "data:image/png;base64," + mask;
    } else {
        // if NO mask available or BBox-only mode
        if (drawMode !== "mask") {
            ctx.strokeStyle = bboxColor;
            ctx.lineWidth = 2;
            ctx.strokeRect(x1, y1, x2-x1, y2-y1);

            if (drawMode === "labels") {
                ctx.fillStyle = bboxColor.replace(')', ', 0.7)').replace('rgb', 'rgba');
                ctx.fillRect(x1, y1 - 20, 150, 20);

                ctx.fillStyle = 'white';
                ctx.font = '14px Arial';
                ctx.fillText(`${className}: ${(confidence * 100).toFixed(1)}%`, x1+5, y1-5);
            }
        }
    }
}


    function prepareDetectionOverlays(detectionData) {
        return detectionData.map((detection) => {
            return {
                id: detection.id,
                class: detection.class,
                confidence: detection.confidence,
                bbox: detection.bbox,
                color: detection.color,
                mask: detection.mask || null
            };
        });
    }

    // Client-side filtering function
    function filterImage(selectedIds) {
        drawImageWithFilter(selectedIds);
    }

    document.getElementById("fileInput").addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        const formData = new FormData();
        formData.append("image", file);

        try {
            const response = await fetch("/predict", {
                method: "POST",
                body: formData
            });

            const result = await response.json();
            
            if (result.error) {
                throw new Error(result.error);
            }
            
            currentDetections = result.detections;
            currentImageData = result.annotated_image;
            currentDetectionData = result.detection_data || [];
            originalImageData = result.original_image;
            
            await initializeCanvas();
            
            // Load original image
            originalImage = new Image();
            originalImage.onload = function() {
                canvas.width = originalImage.width;
                canvas.height = originalImage.height;
                
                // Prepare detection overlays
                detectionOverlays = prepareDetectionOverlays(currentDetectionData);
                
                // Draw image with all detections
                drawImageWithFilter();
            };
            originalImage.src = "data:image/jpeg;base64," + originalImageData;
            
            // Update the detection cards
            updateDetectionCards(currentDetections);
            
            // Update detection counter
            updateDetectionCounter(currentDetections);
            
        } catch (error) {
            console.error("Error:", error);
            alert("An error occurred while processing the image: " + error.message);
        }
    });

    function updateDetectionCards(detections) {
        const container = document.getElementById("detectionsContainer");
        container.innerHTML = "";
        
        if (!detections || detections.length === 0) {
            container.innerHTML = `
                <div class="card">
                    <h3>No Issues Detected</h3>
                    <p>No dental issues were detected in this X-ray.</p>
                </div>
            `;
            return;
        }
        
         //filter controls
        const filterControls = document.createElement("div");
        filterControls.style.marginBottom = "15px";
        filterControls.innerHTML = `
            <button id="showAllBtn" class="filter-btn active" style="margin-right: 10px; padding: 8px 12px; background-color: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer;">
                Show All
            </button>
            <span style="font-weight: bold;">Filter by class:</span>
        `;
        container.appendChild(filterControls);
        
        //click event to Show All button
        document.getElementById("showAllBtn").addEventListener("click", () => {
            document.querySelectorAll(".class-filter-btn").forEach(btn => {
                btn.classList.remove("active");
            });
            document.getElementById("showAllBtn").classList.add("active");
            
            activeFilter = null;
            selectedDetections.clear();
            renderDetectionCards(currentDetections);
            
            // Show all detections on canvas
            filterImage(null);
            
        });
        
        // Create a card for each detection
        renderDetectionCards(detections);
        
        //class filter buttons
        const uniqueClasses = [...new Set(detections.map(d => d.class))];
        uniqueClasses.forEach(className => {
            const filterBtn = document.createElement("button");
            filterBtn.textContent = className;
            filterBtn.className = "class-filter-btn";
            filterBtn.style.margin = "5px";
            filterBtn.style.padding = "5px 10px";
            filterBtn.style.backgroundColor = "#ecf0f1";
            filterBtn.style.border = "none";
            filterBtn.style.borderRadius = "4px";
            filterBtn.style.cursor = "pointer";
            
            filterBtn.addEventListener("click", () => {
                document.querySelectorAll(".class-filter-btn").forEach(btn => {
                    btn.classList.remove("active");
                });
                document.getElementById("showAllBtn").classList.remove("active");
                filterBtn.classList.add("active");
                
                activeFilter = className;
                const filteredDetections = currentDetections.filter(d => d.class === className);
                selectedDetections.clear();
                renderDetectionCards(filteredDetections);
                
                // Filter image to show only this class
                const classIds = filteredDetections.map(d => d.id);
                filterImage(classIds);
                
            });
            
            filterControls.appendChild(filterBtn);
        });
    }

    function renderDetectionCards(detections) {
        const container = document.getElementById("detectionsContainer");
        
        // Remove existing cards (but keep filter controls)
        const filterControls = container.querySelector("div");
        const existingCards = container.querySelectorAll(".detection-card");
        existingCards.forEach(card => card.remove());
        
        if (!detections || detections.length === 0) {
            const noResults = document.createElement("div");
            noResults.className = "card";
            noResults.innerHTML = `
                <h3>No Matching Issues</h3>
                <p>No dental issues match the current filter.</p>
            `;
            container.appendChild(noResults);
            return;
        }
        
        //card creation
        detections.forEach((detection) => {
            const card = document.createElement("div");
            card.className = "detection-card";
            card.style.cursor = "pointer";
            card.style.transition = "all 0.3s ease";
            card.dataset.detectionId = detection.id;

            card.innerHTML = `
                <h4>${detection.class}</h4>
                <p><span class="types" data-type="${detection.types}">${detection.types}</span></p>
                <p>ID: ${detection.id}</p>
                <p>Description: ${detection.description}</p>
                <p>Confidence: <span class="confidence">${(detection.confidence * 100).toFixed(1)}%</span></p>
                <button class="focus-btn" style="margin-top: 10px; padding: 5px 10px; font-size: 12px; background-color: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; display: none;">
                </button>
            `;
            
            //click event
            card.addEventListener("click", () => {
                const cardId = detection.id;

                if (selectedDetections.has(cardId)) {
                    // Deselect this card
                    selectedDetections.delete(cardId);
                    card.style.border = 'none';
                    card.style.backgroundColor = '';
                } else {
                    // Select this card
                    selectedDetections.add(cardId);
                    card.style.border = '2px solid #3498db';
                    card.style.backgroundColor = '#f0f8ff';
                }

                if (selectedDetections.size > 0) {
                    // Show only selected cards
                    filterImage(Array.from(selectedDetections));
                } else {
                    if (activeFilter) {
                        const filteredDetections = currentDetections.filter(d => d.class === activeFilter);
                        renderDetectionCards(filteredDetections);
                        filterImage(filteredDetections.map(d => d.id));
                    } else {
                        filterImage(null);
                    }
                }
            });
            
            //hover effect
            card.addEventListener("mouseenter", () => {
                card.style.boxShadow = "0 4px 8px rgba(0, 0, 0, 0.2)";
                card.style.transform = "translateY(-2px)";
            });
            
            card.addEventListener("mouseleave", () => {
                if (card.style.border !== '2px solid #3498db') {
                    card.style.boxShadow = "0 2px 4px rgba(0, 0, 0, 0.1)";
                }
                card.style.transform = "translateY(0)";
            });
            
            container.appendChild(card);
        });
    }

    function updateRecommendations(detections) {
        const container = document.getElementById("recommendationsList");
        container.innerHTML = "";
        
        if (!detections || detections.length === 0) {
            container.innerHTML = `
                <p>No specific recommendations needed. Maintain good oral hygiene and regular checkups.</p>
            `;
            return;
        }
        
        const ul = document.createElement("ul");
        
        detections.forEach(detection => {
            const li = document.createElement("li");
            
            // Custom recommendations based on detection class
            const className = detection.class.toLowerCase();
            
            if (className.includes("caries") || className.includes("decay")) {
                li.textContent = `For ${detection.class}: Dental filling is recommended to prevent further decay.`;
            } else if (className.includes("crack") || className.includes("fracture")) {
                li.textContent = `For ${detection.class}: Dental crown may be needed to protect the tooth.`;
            } else if (className.includes("infection") || className.includes("lesion")) {
                li.textContent = `For ${detection.class}: Root canal treatment may be necessary.`;
            } else if (className.includes("missing")) {
                li.textContent = `For ${detection.class}: Consider dental implants or bridges.`;
            } else {
                li.textContent = `For ${detection.class}: Further examination by a dentist is recommended.`;
            }
            
            ul.appendChild(li);
        });
        
        const generalLi = document.createElement("li");
        generalLi.textContent = "Maintain improved oral hygiene practices and schedule regular dental visits.";
        ul.appendChild(generalLi);
        
        container.appendChild(ul);
    }
</script>
</html>